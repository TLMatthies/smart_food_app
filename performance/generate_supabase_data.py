import os
from datetime import datetime
import sqlalchemy
from dotenv import load_dotenv
from faker import Faker
import numpy as np

# Load environment variables
load_dotenv()

def get_db_url():
    user = os.getenv('SUPABASE_USER')
    password = os.getenv('SUPABASE_PASSWORD')
    host = os.getenv('SUPABASE_HOST')
    port = os.getenv('SUPABASE_PORT')
    db = os.getenv('SUPABASE_DB')
    
    return f"postgresql+psycopg2://{user}:{password}@{host}:{port}/{db}"

# Create engine using environment variables
engine = sqlalchemy.create_engine(get_db_url(), use_insertmanyvalues=True)

fake = Faker()

# Configuration
NUM_STORES = 100
NUM_FOOD_ITEMS = 5000
ITEMS_PER_STORE = 1000

# Location settings
SLO_LAT = 35.3050
SLO_LONG = -120.6625

# Pre-defined data
STORE_NAMES = [
    "Trader Joe's", "Campus Market", "Village Market",
    "California Fresh Market", "Whole Foods Market",
    "Smart & Final", "Food 4 Less", "Grocery Outlet"
]

COMMON_ITEMS = [
    ("Milk", 64, 150, 8, 0, 0, 12, 12, 8),
    ("Bread", 20, 250, 1, 0, 2, 45, 3, 8),
    ("Eggs", 12, 70, 2, 0, 0, 0, 0, 6),
    ("Banana", 1, 105, 0, 0, 3, 27, 14, 1),
    ("Chicken Breast", 1, 120, 1, 0, 0, 0, 0, 26)
]

FOOD_CATEGORIES = {
    'Produce': ['Fresh', 'Organic', 'Local', 'Seasonal', 'Ripe'],
    'Dairy': ['Whole', 'Low-fat', 'Organic', 'Farm Fresh', 'Cultured'],
    'Meat': ['Fresh', 'Lean', 'Ground', 'Premium', 'Choice'],
    'Bakery': ['Fresh Baked', 'Artisan', 'Whole Grain', 'Gluten-Free', 'Homestyle'],
    'Pantry': ['Premium', 'Organic', 'Natural', 'Classic', 'Gourmet'],
    'Snacks': ['Crunchy', 'Sweet', 'Salty', 'Savory', 'Spicy'],
    'Beverages': ['Natural', 'Sparkling', 'Fresh', 'Premium', 'Classic']
}

FOOD_WORDS = [
    'Apple', 'Orange', 'Carrot', 'Potato', 'Spinach', 'Tomato', 'Cucumber',
    'Cheese', 'Yogurt', 'Cream', 'Butter', 'Cottage Cheese',
    'Beef', 'Pork', 'Turkey', 'Lamb', 'Fish',
    'Roll', 'Muffin', 'Cake', 'Cookie', 'Pastry',
    'Rice', 'Pasta', 'Beans', 'Soup', 'Cereal',
    'Chips', 'Crackers', 'Nuts', 'Popcorn', 'Pretzels',
    'Tea', 'Coffee', 'Juice', 'Soda', 'Water'
]

def reset_tables(conn):
    print("Setting up extensions and resetting tables...")
    
    # Enable required extensions
    conn.execute(sqlalchemy.text("CREATE EXTENSION IF NOT EXISTS cube;"))
    conn.execute(sqlalchemy.text("CREATE EXTENSION IF NOT EXISTS earthdistance;"))
    
    # Drop relevant tables if they exist
    conn.execute(sqlalchemy.text("""
        DROP TABLE IF EXISTS catalog_item CASCADE;
        DROP TABLE IF EXISTS catalog CASCADE;
        DROP TABLE IF EXISTS food_item CASCADE;
        DROP TABLE IF EXISTS store CASCADE;
    """))
    
    # Recreate tables
    conn.execute(sqlalchemy.text("""
        CREATE TABLE public.store (
            store_id integer GENERATED BY DEFAULT AS IDENTITY NOT NULL,
            name text,
            catalog_id integer,
            latitude double precision,
            longitude double precision,
            open_time timestamp without time zone,
            close_time timestamp without time zone,
            CONSTRAINT store_pkey PRIMARY KEY (store_id)
        );

        CREATE TABLE public.food_item (
            food_id bigint GENERATED BY DEFAULT AS IDENTITY NOT NULL,
            name text,
            serving_size int,
            calories integer,
            saturated_fat integer,
            trans_fat integer,
            dietary_fiber integer,
            total_carbohydrate integer,
            total_sugars integer,
            protein integer,
            CONSTRAINT food_item_pkey PRIMARY KEY (food_id)
        );

        CREATE TABLE public.catalog (
            catalog_id integer GENERATED BY DEFAULT AS IDENTITY NOT NULL,
            store_id integer,
            CONSTRAINT catalog_pkey PRIMARY KEY (catalog_id)
        );

        CREATE TABLE public.catalog_item (
            catalog_item_id integer GENERATED BY DEFAULT AS IDENTITY NOT NULL,
            catalog_id integer,
            food_id integer,
            price integer,
            quantity integer,
            CONSTRAINT catalog_item_pkey PRIMARY KEY (catalog_item_id),
            CONSTRAINT catalog_item_catalog_id_fkey FOREIGN KEY (catalog_id) REFERENCES catalog (catalog_id),
            CONSTRAINT catalog_item_food_id_fkey FOREIGN KEY (food_id) REFERENCES food_item (food_id)
        );
    """))
    
    print("Tables reset successfully")

def create_store_hours():
    now = datetime.now()
    open_time = now.replace(hour=8, minute=0)
    close_time = now.replace(hour=22, minute=0)
    return open_time, close_time

def generate_location(center_lat, center_long, spread):
    lat = center_lat + np.random.normal(0, spread)
    long = center_long + np.random.normal(0, spread)
    return lat, long

def generate_stores():
    stores = []
    # Add real stores
    for name in STORE_NAMES:
        lat, long = generate_location(SLO_LAT, SLO_LONG, 0.1)
        open_time, close_time = create_store_hours()
        store = {
            "name": name,
            "latitude": lat,
            "longitude": long,
            "open_time": open_time,
            "close_time": close_time,
            "catalog_id": None
        }
        stores.append(store)
    
    # Add generated stores
    remaining_stores = NUM_STORES - len(STORE_NAMES)
    for _ in range(remaining_stores):
        lat, long = generate_location(SLO_LAT, SLO_LONG, 0.1)
        open_time, close_time = create_store_hours()
        store = {
            "name": f"{fake.company()} Market",
            "latitude": lat,
            "longitude": long,
            "open_time": open_time,
            "close_time": close_time,
            "catalog_id": None
        }
        stores.append(store)
    return stores

def generate_food_items():
    food_items = []
    
    # Add common items first
    for name, size, cal, sat, trans, fiber, carb, sugar, protein in COMMON_ITEMS:
        food_items.append({
            "name": name,
            "serving_size": size,
            "calories": cal,
            "saturated_fat": sat,
            "trans_fat": trans,
            "dietary_fiber": fiber,
            "total_carbohydrate": carb,
            "total_sugars": sugar,
            "protein": protein
        })
    
    # Generate items for each category
    remaining_items = NUM_FOOD_ITEMS - len(COMMON_ITEMS)
    items_per_category = remaining_items // len(FOOD_CATEGORIES)
    
    for category, prefixes in FOOD_CATEGORIES.items():
        for _ in range(items_per_category):
            name = f"{np.random.choice(prefixes)} {np.random.choice(FOOD_WORDS)} {category}"
            food_items.append({
                "name": name,
                "serving_size": np.random.randint(1, 16),
                "calories": np.random.randint(0, 500),
                "saturated_fat": np.random.randint(0, 20),
                "trans_fat": np.random.randint(0, 2),
                "dietary_fiber": np.random.randint(0, 7),
                "total_carbohydrate": np.random.randint(0, 50),
                "total_sugars": np.random.randint(0, 25),
                "protein": np.random.randint(0, 25)
            })
    
    return food_items

print("Starting data generation...")

with engine.begin() as conn:
    # Reset tables
    reset_tables(conn)
    
    print("Generating stores...")
    stores = generate_stores()
    store_ids = []
    for store in stores:
        result = conn.execute(
            sqlalchemy.text("""
            INSERT INTO store (name, latitude, longitude, open_time, close_time)
            VALUES (:name, :latitude, :longitude, :open_time, :close_time)
            RETURNING store_id
            """),
            store
        )
        store_ids.append(result.scalar_one())
    
    print("Generating food items...")
    food_items = generate_food_items()
    food_ids = []
    for item in food_items:
        result = conn.execute(
            sqlalchemy.text("""
            INSERT INTO food_item (name, serving_size, calories, saturated_fat, 
                                trans_fat, dietary_fiber, total_carbohydrate, 
                                total_sugars, protein)
            VALUES (:name, :serving_size, :calories, :saturated_fat,
                    :trans_fat, :dietary_fiber, :total_carbohydrate,
                    :total_sugars, :protein)
            RETURNING food_id
            """),
            item
        )
        food_ids.append(result.scalar_one())

    print("Generating catalogs and catalog items...")
    for i, store_id in enumerate(store_ids, 1):
        # Create catalog for store
        catalog_id = conn.execute(
            sqlalchemy.text("""
            INSERT INTO catalog (store_id)
            VALUES (:store_id)
            RETURNING catalog_id
            """),
            {"store_id": store_id}
        ).scalar_one()
        
        # Add items to catalog
        # Common items
        base_foods = food_ids[:5]
        other_foods = np.random.choice(food_ids[5:], ITEMS_PER_STORE - 5, replace=False)
        selected_foods = np.concatenate([base_foods, other_foods])
        
        catalog_items = []
        for food_id in selected_foods:
            base_price = np.random.lognormal(mean=1.5, sigma=0.5)
            catalog_items.append({
                "catalog_id": int(catalog_id),
                "food_id": int(food_id),
                "price": int(base_price * 100),  # Convert to cents
                "quantity": int(np.random.randint(10, 200))
            })
        
        # Insert catalog items in chunks to avoid memory issues
        for chunk in [catalog_items[i:i + 100] for i in range(0, len(catalog_items), 100)]:
            conn.execute(
                sqlalchemy.text("""
                INSERT INTO catalog_item (catalog_id, food_id, price, quantity)
                VALUES (:catalog_id, :food_id, :price, :quantity)
                """),
                chunk
            )
        print(f"Processed store {i}/{len(store_ids)}")

print("Data generation complete")